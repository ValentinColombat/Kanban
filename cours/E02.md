# Auth

---

Git et Github workflow avec branches

---

## Mise en place d'un exemple de worklow Git/Github que l'on pourrait trouver en entreprise

Quand on créé un dépôt git, il est créé avec une branch par défaut, qui s'appelle la branche `master`

- On privilégie les noms de branche non controversé, on renomme si nécessaire :

- `-M` cette option permet de renommer la branche principale d'un dépôt.

- `git branch -M main`

- `git branch -a` pour lister toutes les branches (locales et distantes)

### Création de branche locale et distante

- `git checkout -b nomBranche`
- `git push --set-upstream origin nomBranche`

### Workflow

En local, on a terminé notre développement, on a fait notre code review locale, on peut pousher sur la branche distante, créer une pull request (PR), demander une code review au boss, et on espère qu'il va merger.

On a crée une issue, et on a relié notre PR à cette issue en la mentionnant (#1), ce qui permet dfe déclencher des automatisations sur github.

Le code review a eu lieu, nos modifications ont été accepté et fusionner avec la branche main, dans le message de fusion, on a mentionné l'issue sur laquelle on travaillait (fix #1) ce qui a permis de fermer l'issue au moment ou la PR a été acceptée.

Quand le code a été fusionné, on revient en local, et on se repositionne sur la branche main, et on fait `git pull`, pour intégrer les changements distants.

Pour effacer une branche locale :

`git branch -d nomBranch`

On est prêt a créer une nouvelle branche et à prendre une nouvelle issue.

## Hash de mot de passe avec argon2

### Le concept de sel et hashage

Le concept de sel est là pour nous permettre d'avoir des hash différents les uns des autres.

Le sel est une string aléatoire que l'on concatène au mot de passe fourni pas l'utilisateur et qu'on va hasher afin d'avoir un hash unique.

On ne hash pas le mot de passe seul, sinon on obtiendrai le même hash tout le temps.

On y ajoute un sel (une string aléatoire) afin d'obtenir des hash uniques à chaque mot de passe.

```js
const clearPass = 'password';
const salt = 'c8224b12268c3c4b56617fb'

const passwordToHash = clearPass + salt;

const hash = await argon2.hash(passwordToHash);
console.log(hash);

// * Ce que fait argon, il obtient le hash du mot de passe, il concatène le sel en clair. ce sel sera récupéré ensuite pour valider le mot de passe.
$argon2id$v=19$m=65536,t=3,p=4$0qdpsM/DH0v7E0/7kU0Xpw$pRowh2X+JDXA9IV+7QiHuekEmoJc00zdZxjivbqO2aA
```

### La vérification du mot de passe

On utilise argon pour vérifier si le mot de passe est correct :

- `await argon.verify(hash, 'clearPassword')`

Argon va aller récupérer le hash, et sur ce hash il va récupérer le sel.
Avec ce sel il va hasher le mot de passe en clair
Et enfin, il va comparer les deux hash pour valider ou non?

```js
oldHash === newHash
timingSafeEqual(oldHash, newHash);
```

Recommandation : quand vous devez comparer deux strings qui viennent du front, il faut utiliser `timingSafeEqual`.

La fonction `timingSafeEqual` ne compare pas les strings directement, masi elle compare les Buffer.

```js
const str = 'test';
const strToCompare = 'test';

if(Number(str.length) === Number(strToCompare.length)) {
    crypto.timingSafeEqual(Buffer.from(str), Buffer.from(strToCompare));
}
```

### Générer un mot de passe aléatoire avec node

Dans le terminal :

```bash
node
```

```js
const crypto = require('crypto');

crypto.randomBytes(32).toString('base64');
#  ou
crypto.randomBytes(32).toString('hex');
```
